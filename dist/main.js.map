{"mappings":";;;;;;;;ACqCO,SAAS;IACd,MAAM,gBAAgB;IACtB,MAAM,mBAAE,eAAe,cAAE,UAAU,EAAE,GAAG;IAExC,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,qBAAO,EACrC;IAGF,SAAS;QACP,IACE,mBACA,iBACA,cAAc,KACd,cAAc,GACd;YACA,MAAM,2BAAE,uBAAuB,yBAAE,qBAAqB,EAAE,GACtD,0CAAwB;YAE1B,MAAM,UAAU,OAAO;YACvB,MAAM,UAAU,OAAO;YAEvB,MAAM,cAAc;gBAClB,GAAG,cAAc,IAAI,UAAU;gBAC/B,GAAG,cAAc,IAAI,UAAU;YACjC;YAEA,IAAI,KAAK,UAAU,iBAAiB,KAAK,UAAU,WACjD,YAAY;QAEhB;IACF;IAEA;IAEA,MAAM,cAAc,CAAC,WACjB,OACA,KAAK,IAAI,SAAS,KAAK,KAAK,IAAI,SAAS;IAE7C,OAAO;QACL,UAAU;oBACV;QACA,WAAW,UAAU,KAAK;QAC1B,WAAW,UAAU,KAAK;IAC5B;AACF;AAKO,SAAS;IACd,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qBAAO,EAG9C;QACD,GAAG;QACH,GAAG;IACL;IAEA,CAAA,GAAA,sBAAQ,EAAE;QACR,SAAS,oBAAoB,EAAc;YACzC,iBAAiB;gBAAE,GAAG,GAAG;gBAAS,GAAG,GAAG;YAAQ;QAClD;QAEA,OAAO,iBAAiB,aAAa;QAErC,OAAO;YACL,OAAO,oBAAoB,aAAa;QAC1C;IACF,GAAG,EAAE;IAEL,OAAO;AACT;AAMO,SAAS;IACd,MAAM,aAAa,CAAA,GAAA,mBAAK,EAAuB;IAC/C,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qBAAO,EAAkB;IAEvE,MAAM,2BAA2B,CAAA,GAAA,wBAAU,EAAE;QAC3C,IAAI,WAAW,SAAS;YACtB,MAAM,cAAc,WAAW,QAAQ;YACvC,MAAM,UAAU,OAAO;YACvB,MAAM,UAAU,OAAO;YAEvB,MAAM,8BAA8B;gBAClC,GAAG,YAAY,QAAQ;gBACvB,MAAM,YAAY,OAAO;gBACzB,KAAK,YAAY,MAAM;YACzB;YAEA,IACE,KAAK,UAAU,iCACf,KAAK,UAAU,kBAEf,mBAAmB;QAEvB;IACF,GAAG;QAAC;KAAgB;IAEpB,sBAAsB;IACtB,CAAA,GAAA,4BAAc,EAAE;QACd,OAAO,iBAAiB,UAAU;QAElC,OAAO;YACL,OAAO,oBAAoB,UAAU;QACvC;IACF,GAAG;QAAC;KAAyB;IAE7B;IAEA,OAAO;oBAAE;yBAAY;IAAgB;AACvC;AASO,SAAS,0CAAwB,OAAgB;IACtD,MAAM,yBAAyB,QAAQ,QAAQ;IAC/C,MAAM,uBAAuB,QAAQ,SAAS;IAE9C,MAAM,0BAA0B,QAAQ,OAAO;IAC/C,MAAM,wBAAwB,QAAQ,MAAM;IAE5C,OAAO;iCAAE;+BAAyB;IAAsB;AAC1D","sources":["src/index.ts","src/use-mouse-distance.ts"],"sourcesContent":["export { useMouseDistance } from './use-mouse-distance'\n","import {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react'\n\n/**\n * Calculates the distance between an element and the mouse.\n *\n * @returns `elementRef` Element reference\n * @returns `distance` Sum of the distance (absolute number)\n * @returns `distanceX` Horizontal distance. Can be negative.\n * @returns `distanceY` Vertical distance. Can be negative.\n *\n * @example\n * ```tsx\n * import { useMouseDistance } from 'use-mouse-distance'\n *\n * function MyComponent() {\n *   const { elementRef, distance, distanceX, distanceY } =\n *     useMouseDistance<HTMLDivElement>()\n *\n *   return (\n *     <div>\n *       <div ref={elementRef}>\n *         <p>Distance sum (absolute): {distance}</p>\n *         <p>Distance x: {distanceX}</p>\n *         <p>Distance y: {distanceY}</p>\n *       </div>\n *     </div>\n *   )\n * }\n * ```\n *\n */\nexport function useMouseDistance<TElementType extends HTMLElement>() {\n  const mousePosition = useMousePosition()\n  const { elementPosition, elementRef } = useElementPostition<TElementType>()\n\n  const [distance, setDistance] = useState<{ x: number; y: number } | null>(\n    null,\n  )\n\n  function calculateDistanceFromMouseToCenter() {\n    if (\n      elementPosition &&\n      mousePosition &&\n      mousePosition.x &&\n      mousePosition.y\n    ) {\n      const { elementHorizontalCenter, elementVerticalCenter } =\n        calculateElementCenters(elementPosition)\n\n      const scrollX = window.scrollX\n      const scrollY = window.scrollY\n\n      const distanceNew = {\n        x: mousePosition.x + scrollX - elementHorizontalCenter,\n        y: mousePosition.y + scrollY - elementVerticalCenter,\n      }\n\n      if (JSON.stringify(distanceNew) !== JSON.stringify(distance)) {\n        setDistance(distanceNew)\n      }\n    }\n  }\n\n  calculateDistanceFromMouseToCenter()\n\n  const distanceSum = !distance\n    ? null\n    : Math.abs(distance.x) + Math.abs(distance.y)\n\n  return {\n    distance: distanceSum,\n    elementRef,\n    distanceX: distance?.x ?? null,\n    distanceY: distance?.y ?? null,\n  }\n}\n\n/**\n * Returns the current `x` and `y` position of the mouse. Updates via the `mousemove` event.\n */\nexport function useMousePosition() {\n  const [mousePosition, setMousePosition] = useState<{\n    x: number | null\n    y: number | null\n  }>({\n    x: null,\n    y: null,\n  })\n\n  useEffect(() => {\n    function updateMousePosition(ev: MouseEvent) {\n      setMousePosition({ x: ev.clientX, y: ev.clientY })\n    }\n\n    window.addEventListener('mousemove', updateMousePosition)\n\n    return () => {\n      window.removeEventListener('mousemove', updateMousePosition)\n    }\n  }, [])\n\n  return mousePosition\n}\n\n/**\n * Returns an element ref and its position.\n * Also listens to the `scroll` event.\n */\nexport function useElementPostition<TElementType extends HTMLElement>() {\n  const elementRef = useRef<TElementType | null>(null)\n  const [elementPosition, setElementPosition] = useState<DOMRect | null>(null)\n\n  const calculateElementPosition = useCallback(() => {\n    if (elementRef.current) {\n      const positionNew = elementRef.current.getBoundingClientRect()\n      const scrollX = window.scrollX\n      const scrollY = window.scrollY\n\n      const positionNewWithScrollOffset = {\n        ...positionNew.toJSON(),\n        left: positionNew.left + scrollX,\n        top: positionNew.top + scrollY,\n      }\n\n      if (\n        JSON.stringify(positionNewWithScrollOffset) !==\n        JSON.stringify(elementPosition)\n      ) {\n        setElementPosition(positionNewWithScrollOffset)\n      }\n    }\n  }, [elementPosition])\n\n  // calculate on scroll\n  useLayoutEffect(() => {\n    window.addEventListener('scroll', calculateElementPosition)\n\n    return () => {\n      window.removeEventListener('scroll', calculateElementPosition)\n    }\n  }, [calculateElementPosition])\n\n  calculateElementPosition()\n\n  return { elementRef, elementPosition }\n}\n\n/**\n * Calculates the horizontal and vertical center of an element.\n *\n * Takes the `DOMRect` of an element, e.g. from `getBoundingClientRect()`.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/DOMRect\n */\nexport function calculateElementCenters(element: DOMRect) {\n  const horizontalCenterOffset = element.width / 2\n  const verticalCenterOffset = element.height / 2\n\n  const elementHorizontalCenter = element.left + horizontalCenterOffset\n  const elementVerticalCenter = element.top + verticalCenterOffset\n\n  return { elementHorizontalCenter, elementVerticalCenter }\n}\n"],"names":[],"version":3,"file":"main.js.map"}